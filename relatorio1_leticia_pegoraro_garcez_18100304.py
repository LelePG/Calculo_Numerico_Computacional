# -*- coding: utf-8 -*-
"""Relatorio1_Leticia_Pegoraro_Garcez_18100304.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ip8c43m4WsRp_W94nme4JYciP_2tdEVh

#Bibliotecas
"""

import matplotlib.pyplot as plt
import numpy as np
import math

"""# M√©todos"""

def guardaFuncao (x,exer): #seleciona a f√≥rmula do exerc√≠o e retorna seu valor
  if exer ==1:
    return x**10-1
  elif exer ==2:
    return x**3-6*x**2+11*x-6.1
  elif exer ==3:
    return (x/2)**2 - math.sin(x)
  elif exer ==4:
    return x**5-16.05*x**4+88.75*x**3-192.0375*x**2+116.35*x+31.6875
  else:
    return calcula5(x,exer)

def calcula5 (x,exer):
  if exer =='a':
    return math.exp(-x**2) - math.cos(x)
  elif exer =='b':
    return (x**3)-x-1
  elif exer =='c':
    return 4*math.sin(x)-math.exp(x)
  elif exer =='d':
    return (x*math.log10(x))-1
  else:
    return x

def guardaDerivada (x,exer):
  if exer == 2:
    return 6*x-12
  elif exer == 4:
    return 5*x**4-64.2*x**3+266.25*x**2-384.075*x+116.35
  elif exer =='a':
    return (-1+math.exp(x) * math.sin(x))/math.exp(x)
  elif exer =='b':
    return 2*x**2-1
  elif exer =='c':
    return 4*math.cos(x)-math.exp(x)
  elif exer =='d':
    return math.log10(x)+(1/math.log(10))
  else:
    return x

def bissec(a,b,exer,inter=10000000, prec = 0.00000000000000001):
  for k in range(inter):
    if (b-a) < prec:
      return x
    x = (a+b)/2
    fa = guardaFuncao(a,exer)
    fx = guardaFuncao(x,exer)
    ##print(k,a,x,fa,fx)##debug
    if fa*fx >0:
     a=x
    elif fa*fx <0:
     b=x
    if (b-a)<prec:
     return x
  return x

def falcaPos(a,b,exer,inter=10000000, prec1= 0.00000000000000001, prec2= 0.00000000000000001):
  for k in range (inter):
    fa = guardaFuncao(a,exer)
    fb= guardaFuncao(b,exer)
    if (b-a) < prec1:
      if abs(fa)< prec2:
        return a
      elif abs(fb)< prec2:
        return b
    x=(a*fb - b*fa)/(fb-fa)
    fx = guardaFuncao(x,exer)
    ##print(k,x,fx)##debug
    if abs(fx) < prec2:
      return x
    if fa*fx >0:
      a=x
    else:
      b=x
    if (b-a)<prec1:
      return x
  return x

def tangente(x0,exer, inter=100000000,prec1 = 0.0000000000001, prec2 = 0.0000000001):
  for k in range(inter):
    if abs(guardaFuncao(x0,exer)) < prec1:
      return x0
    x1 = x0-(guardaFuncao(x0,exer)/guardaDerivada(x0,exer))
    ##print(k,x0,guardaFuncao(x0,exer))##debug
    if abs(guardaFuncao(x1,exer)) <prec1 or abs(x1-x0) < prec2:
     return x1
    x0=x1
  return x0

def secante(x0,x1,exer, inter=100000000,prec1 = 0.00000000000000001, prec2 = 0.0000000001):
  for k in range(inter):
    if abs(guardaFuncao(x0,exer)) < prec1:
      return x0
    if abs(guardaFuncao(x1,exer)) < prec1 or abs(x1-x0) < prec2:
      return x1
    x2 = x1-(guardaFuncao(x1,exer)/(guardaFuncao(x1,exer)-guardaFuncao(x0,exer)))*(x1-x0)
    if abs(guardaFuncao(x2,exer)) < prec1 or abs(x2-x1) < prec2:
      return x2
    x0 = x1
    x1 = x2
  return x2##caso seja dado um n√∫mero de itera√ß√µes

"""# Lista de Exerc√≠cio 2

##QuestaÃÉo 1 ‚Äì Determine a raiz da funcÃßaÃÉo f(x) = x^10 - 1 com o meÃÅtodo da bisseccÃßaÃÉo e da falsa posicÃßaÃÉo. Utilize cinco iteracÃßoÃÉes e as aproximacÃßoÃÉes iniciais a = 0 e b = 1,3. Qual dos meÃÅtodos obteve melhor desempenho? Porque?
"""

print("M√©todo da bissec√ß√£o: "+ str(bissec(0,1.3,1,5)))
print("M√©todo da Falsa Posi√ß√£o: " + str(falcaPos(0,1.3,1,5)))

O m√©todo que obteve melhor desempenho foi o m√©todo da bissec√ß√£o, j√° que resolvendo
substituindo na equa√ß√£o, 0=x**10 -1, se fica com x= raiz d√©cima de 1, cujo resultado √© 1 ou -1
Portanto, o m√©todo da bissec√ß√£o √© o que mais se aproxima do resultado.

"""##QuestaÃÉo 2 ‚Äì Determine a maior raiz real de f(x) = x^3 ‚Äì 6x^2 + 11x ‚Äì 6,1 

1. Graficamente
2. Usando o meÃÅtodo da tangente (treÃÇs iteracÃßoÃÉes, x0=3,5)
3. Usando o meÃÅtodo da secante (treÃÇs iteracÃßoÃÉes, x0=2,5 e x1=3,5)
4. Discuta sobre os resultados obtidos

a)Graficamente
"""

inicio = 0
fim = 4
pts = 100
 
curva = np.linspace(inicio,fim,pts)
coordenadas = [guardaFuncao(valor,2) for valor in curva]
plt.plot(curva,coordenadas)
plt.xlabel("x")
plt.ylabel("F(x)")
plt.grid()
plt.show()
#raizes aproximadas graficamente: 1,2 e 3

"""b)M√©todo da tangente"""

# Commented out IPython magic to ensure Python compatibility.
# %time print("M√©todo da Tangente: " + str(tangente(3.5,2,3)))

"""c).M√©todo da Secante"""

# Commented out IPython magic to ensure Python compatibility.
# %time print("M√©todo da Secante: " + str(secante(2.5,3.5,2,3)))

"""d) Discuss√£o:
Os resultados obtidos se mostraram consistentes, girando em torno de aproximadamente 3 (aproxima√ß√£o visual com base no gr√°fico), para aproximadamente 3.14 (arredondado) no m√©todo da tangente e 3.22 (arredondado) no m√©todo da secante.O resultado obtido analicamente foi 3.046680531804602, portanto o m√©todo da tangente (3.14) foi o que obteu o maior desempenho. Apesar disso, o m√©todo da Secante foi mais r√°pido, levando 225Œº segundos para exibir o resultado

##QuestaÃÉo 3 ‚Äì Use o meÃÅtodo da bisseccÃßaÃÉo para determinar uma raiz de f(x) = (x/2)^2 ‚Äì sen(x) utilizando as aproximacÃßoÃÉes iniciais a = 1,5 e b = 2 e ùúÄ = 0,001% . Explique seus resultados.
"""

# Commented out IPython magic to ensure Python compatibility.
# %time print("M√©todo da Bissec√ß√£o: " + str(bissec(1.5,2,3,prec=0.001)))

"""Explica√ß√£o dos resultados: Os resultados foram obtidos atrav√©s do m√©todo da bissec√ß√£o, com precis√£√£o de 0.001%, ou seja, quando (b-a) < 0.001, o c√≥digo termina sua execu√ß√£o retornando o valor 1.9345703125, obtido ap√≥s mais de 10 intera√ß√µes do c√≥digo(resultado obtido com 10 intera√ß√µes:  1.93408203125), levando 830Œº segundos totais de processamento, j√° que  o algortimo s√≥ para uma vez que a precis√£o desejada tenha sido aingida.

##QuestaÃÉo 4 ‚Äì Use o meÃÅtodo da tangente para determinar uma raiz de f(x) = x^5 ‚Äì 16,05x^4 + 88,75x^3 ‚Äì 192,0375x^2 + 116,35x + 31,6875 utilizando uma aproximacÃßaÃÉo inicial de x0 = 0,5825 e ùúÄ = 0,01% . Explique seus resultados.
"""

# Commented out IPython magic to ensure Python compatibility.
# %time print(tangente(0.5825,4,prec1=0.01,prec2=0.01))#como foi dada s√≥ uma precis√£o, assumi as duas como sendo iguais

"""Explica√ß√£o dos resultados:
O resultado obtido √© uma aproxima√ß√£o do resultado da equa√ß√£√£o obtido pelo m√©todo da tangente, utilizado um valor inicial de 0.5825 e precis√£o de 0.01%.
A partir de um valor inicial x0, neste caso, 0.5825, √© selecionado um valor x1, sendo que x1 corresponde a x0-(f(x0)/f'(x0)). Ap√≥s isso, √©√© verificado se a precis√£o desejada foi atingida. Em caso negativo, √© feito x0=x1, e uma nova itera√ß√£o come√ßa.
O resultado obtido (6.500017452342041), aparece ap√≥s se constatar que o valor de f(x1) √© menor que a precis√£o, ou que o m√≥dulo de (x1-x0) √© menor que a precis√£o estabelecida. O tempo total de execu√ß√£o do c√≥digo em wall time foi de 227Œº segundos, enquanto o tempo total em que a CPU esteve ocupada foi de 262Œº segundos

## QuestaÃÉo 5 ‚Äì Compare o desempenho dos meÃÅtodos da BisseccÃßaÃÉo, Falsa PosicÃßaÃÉo, Tangente e Secante nas equacÃßoÃÉes abaixo:
1. f(x)=e^(-x^2)-cos(x) ùúÄ1=ùúÄ2=10^-4 ùúâ ‚àà [1, 2]
2. f(x)=x^3-x-1         ùúÄ1=ùúÄ2=10^-6 ùúâ ‚àà [1, 2] 
3. f(x)=4sen(x)-e^x     ùúÄ1=ùúÄ2=10^-5 ùúâ ‚àà [0, 1] 
4. f(x)=xlog(x)-1       ùúÄ1=ùúÄ2=10^-7 ùúâ ‚àà [2, 3]
"""

#1
print("M√©todo da Bissec√ß√£o: " + str(bissec(1,2,'a',prec=0.0001)))
print("M√©todo da Falsa Posi√ß√£o: " + str(falcaPos(1,2,'a',prec1=0.0001,prec2=0.0001)))
print("M√©todo da Tangente: " +str(tangente(1,'a',prec1=0.0001)))
print("M√©todo da Secante: " +str(secante(1,2,'a',prec1=0.0001,prec2=0.0001)))
#O resultado obtido analicamente foi 1.44741427129624. O m√©todo com o resultado mais pr√≥ximo, e portanto maior desempenho foi o da Secante, seguido pelo da bissec√ß√£o, falsa posi√ß√£o e tangente.

#2
print("M√©todo da Bissec√ß√£o: " + str(bissec(1,2,'b',prec=0.000001)))
print("M√©todo da Falsa Posi√ß√£o: " + str(falcaPos(1,2,'b',prec1=0.000001,prec2=0.000001)))
print("M√©todo da Tangente: " +str(tangente(1.0,'b',prec1=0.000001)))
print("M√©todo da Secante: " +str(secante(1,2,'b',prec1=0.000001,prec2=0.000001)))
 
#O resultado obtido analicamente √© 1.3247179572447458, portanto o m√©todo com o maior desempenho √© o m√©todo da Secante, que mais se aproximou do resultado, seguido pelo m√©todo da falsa posi√ß√£o, da bissec√ß√£o e da tangente

#3
print("M√©todo da Bissec√ß√£o: " + str(bissec(0,1,'c',prec=0.00001)))
print("M√©todo da Falsa Posi√ß√£o: " + str(falcaPos(0,1,'c',prec1=0.00001,prec2=0.00001)))
print("M√©todo da Tangente: " +str(tangente(0,'c',prec1=0.00001)))
print("M√©todo da Secante: " +str(secante(0,1,'c',prec1=0.00001,prec2=0.00001)))
#O resultado obtido analiticamente foi 0.370558095969825. O m√©todo que mais se aproximou deste resultado, e portanto o com maior desempemho foi o m√©todo da secante,seguido pelo m√©todo da tangente e da falsa posi√ß√£o, e por fim o m√©todo da bissec√ß√£o

#4
print("M√©todo da Bissec√ß√£o: " + str(bissec(2,3,'d',prec=0.0000001)))
print("M√©todo da Falsa Posi√ß√£o: " + str(falcaPos(2,3,'d',prec1=0.0000001,prec2=0.0000001)))
print("M√©todo da Tangente: " +str(tangente(2,'d',prec1=0.000001)))
print("M√©todo da Secante: " +str(secante(2,3,'d',prec1=0.000001,prec2=0.000001)))